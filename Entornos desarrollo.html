<!DOCTYPE html>

<html>


<head><!-- \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\ -->

		<title> Apuntes Entornos de desarrollo </title>     


		<meta charset="UTF-8">
		<meta name="author" content="Hector Montesdeoca">
		<meta name="description" content="Mis apuntes pal examen MP5">

		<link rel="stylesheet" type="text/css" href="EstilosGuapos.css">

</head><!-- \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\ -->





<body><!-- \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\ -->



<!--  ========================================    Cabecera   ======================================================== -->
	<header>
		
		<h1> Apuntes Entornos de desarrollo </h1>  
<img src="Fotos\logo.jpg">
					



	 </header> 


<!--  ========================================    Menu navegacion   ================================================== -->
	<nav>  

		<h2>  <a href ="index.html"> Menu </a> </h2>          
				
	 </nav>


<!--  ========================================    UF1 Desarrollo del software   ================= -->
	<section>	 <h1> UF1 Desarrollo del software </h1><hr>

	 	<article>	<h2> Software </h2>
			<ul>
				<li><h3>Clasificacion del software</h3>
                 	<ul>
				 		<li> <h3>Segun el tipo de trabajo que realiza</h3>
				 			<ul>
				 				<li>De sistema</li>
				 				<li>De aplicacion</li>
				 				<li>De programacion</li>
				 			</ul>	
				 		 </li>



				 		 <li> <h3>Segun el metodo de distribucion</h3>
				 			<ul>
				 				<li>Shareware</li>
				 				<li>Freeware</li>
				 				<li>Adware</li>
				 			</ul>
				 		 </li>


				 		<li> <h3>Segun la licencia</h3>
				 			<ul>
				 				<li>Software libre</li>
				 				<li>Propietario</li>
				 			</ul>
				 		 </li>
				 	 </ul>
					 </li><br>

				<li><h3> Concepto programa informatico</h3>
					<p>Es un fragmento de software formado por una secuencia de instrucciones y procesos construido con el fin de cumplir un objetivo concreto</p>
				 </li><br>

				<li> <h3>Arquitectura CPU </h3>
					<p> <b>UC</b> Se encarga de interpretar y ejecutar las instrucciones que se almacenan en la memoria principal y , ademas, genera las senales de control necesarias para ejecutarlas.<br>
					 	<b>UAL</b>  Recibe los datos y ejecuta las operaciones de calculo y comparaciones, decisiones logicas etc.<br>
					 	<b>Registros</b> son la informacion temporal. Almacenamiento interno de la CPU.
					 </p>
					<img src="Fotos/Arquitectura CPU.JPG">
					<img src="Fotos/Arquitectura CPU 2.JPG"><br>

					<p><ul> <h4>Tipos de registros</h4>
						<li><b>CP</b> contador de programa. contiene la direccion de la siguiente instruccion a realizar</li>
						<li><b>RI</b> Es el que contiene el codigo de la instruccion</li>
						<li><b>RDM   </b> Tiene asignada la posicion de la direccion de memoria  </li>
						<li><b>RIM   </b> recibe o envia la informacion que contirne RDM </li>
						<li><b>DI   </b> extrae y analiza el codigo que contiene RI </li>
						<li><b>Reloj   </b> marca el ritmo  </li>
						<li><b>Secuenciador   </b> son ordenes que se sincronizan con el reloj </li>

					</ul></p><br>

					<p><ul> <h4>Fases al ejecutar una instruccion</h4>
							<li><b>Fase de busqueda</b> se localiza la instruccion en memoria y se envia a la unidad de control</li>
							<li><b>Fase de ejecucion</b> ejecutan las acciones de las intrucciones</li>
						</ul></p>
				 </li><br>

				<li><h3>tipos de codigo </h3>
                 	<ul>
				 		<li> <p> codigo fuente</p></li>
				 		<li> <p> codigo objetos</p></li>
				 		<li> <p> codigo ejecutable</p></li>
			        </ul>
			 	 </li><br>

			 	<li><h3>Compilacion</h3><br>
			 		<img src="Fotos/MP5 compilacion.JPG">
			 		<img src="Fotos/MP5 compilacion 2.JPG">
			 	 </li><br>

			 	 <li><h3>Maquina virtual de JAVA</h3><br>
			 		<img src="Fotos/MP5 MV Java.JPG">
			 		
			 	 </li><br>



	 		</ul><!--  ............Fin lista desarrollo software .................... -->
	 	 </article>

	 	<article>	<h2> Lenguaje de programacion </h2>

	 	 		<h3>Clasificacion </h3>
	 	 			
 	 				<h4>Segun su nivel de abstraccion</h4>
 	 					<ul>
 	 						<li>lenguaje de bajo nivel</li>
 	 						<li>lenguaje de nivel medio</li>
 	 						<li>lenguaje de alto nivel</li>
 	 					</ul>
 	 				


 	 				<h4>Segun la forma de ejecucion</h4>
 	 					<ul>
 	 						<li>compilados</li>
 	 						<li>interpretados</li>
 	 					</ul>
 	 				 


 	 				<h4>Segun su paradigma</h4>
 	 					<ul>
 	 						<li>imperativos</li>
 	 						<li>funcionales</li>
 	 						<li>logicos</li>
 	 						<li>estructurados</li>
 	 						<li>orientados aobjetos POO</li>
 	 					</ul>
 	 				


	 	 </article>

	
	 	<article><h2> Desarrollo</h2>


			<h3>Fases del desarrollo</h3>
				
					<h4>Analisis</h4>
						<p>Consiste en la especificaion de las caracteristicas operaticas del software, indica cual es la interfaz que ha de desarrollarse y marca las restricciones de este</p>
						 <ul>
			 				<li>Entrevistas</li>
			 				<li>Desarrollo conjunto de aplicaiones JAD</li>
			 				<li>Planificacion conjunta de requisitos JRP</li>
			 				<li>Brainstrorming</li>
			 				<li>Prototipos</li>
			 				<li>Casos de uso</li>
	 					</ul>

	 					<p><b>Requisitos funcionales</b> describen al detalle la funcion que realiza el sistema, la reaccion ante las entradas y como se comporta en distintas situaciones</p>

	 					<p><b>Requisitos no funcionales</b>Son limitaciones sobre al funcionaliodad que ofrece el sistema.. fiabilibad, la capacidad de almacenamiento, etc</p>


					<h4>Diseño</h4>

						<p><b>Diseno estructurado</b> basado en el flujo de datos a traves del sistema</p>
						<p><b>Diseno orientado a objetos</b></p>


					<h4>codificacion</h4>
						<p>Crear el codigo fuente</p>


					<h4>pruebas</h4>
						<p>Verificacion</p>
						<p>Validacion</p>


					<h4>Documentacion</h4>


					<h4>Explotacion</h4>


					<h4>mantenimiento</h4>

				
	 		

	 		<h3>Modelos de desarrollo</h3>
	 				
				<h4>Modelo en cascada y en cascada con retroalimentacion</h4>
					<img src="Fotos\Modelo en cascada.JPG">
					<img src="Fotos\Modelo en cascada retroalimentado.JPG">  
					<img src="Fotos\Modelo en cascada caracteristicas.JPG">
				<br>


				<h4>Modelo iterativo incremental</h4>
					<img src="Fotos\Modelo  iterativo incremental.JPG">  
					<img src="Fotos\Modelo  iterativo incremental caract.JPG">
				<br>	


				<h4>Modelo en espiral</h4>
					<img src="Fotos\Modelo espiral.JPG">  
					<img src="Fotos\Modelo espiral caract.JPG">
				<br>	


				<h4>Modelo en V</h4>
					<img src="Fotos\Modelo V.JPG">  
					<img src="Fotos\Modelo  v caract.JPG">
				<br>		

	 	 	
	 	 </article>


	 	<article><h2>Metodologias agiles</h2>
	 		<p>Son metodos de gestion que permiten adaptar la forma de trabajo al proyecto, basandose en la flexibilidad y la inmediatez. Lo mas importante es el trabajo colaborativo y el equipo</p>


	 		<h3>SCRUM</h3>
	 			<img src="Fotos/Agile SCRUM.JPG">
	 			<p>Se basa en el trabajo iterativo</p>

	 			<p>Existen tre s fases: Planificacion, cliclos o sprints, documentacion.</p>


	 		<h3>Programacion extrrema (XP)</h3>
	 	 		<img src="Fotos/Agile extrema.JPG">
	 	 		<p>Se centra en potenciar las relaciones interpersonales, promoviendo el trabajo en equipo, preocupandose por el aprendizaje, etc</p>


	 	 	<h3>KANBAN</h3>
	 	 		<img src="Fotos/Agile kanban.JPG">
	 	 		<p>La creo Toyota.Se basa en etiquetas visuales</p>

	 	 </article>




	</section>









<!--  ========================================    UF2 Optimizacion del software   ================= -->
	<section> <h1> UF2 Optimizacion del software </h1><hr>
		
		<article> <h2> Planificacion de pruebas</h2>

			<p>Sera necesario definir <b>PRECONDICIONES</b> y <b>POSTCONDICIONES</b></p>
			<p>Una <b>precondicion</b> es una condicion determinada que debe cumplir un conjunto de parametros</p>
			<p>Una <b>postcondicion</b> es una condicion que cumplira el valor devuelto</p>
			<p>Una <b>asersion</b> es un predicado incluido en el codigo por parte del programador donde se asegura que siempre se va a cumplir en ese punto del programa.</p>
	

			<h3> Pruebas de caja BLANCA</h3>
				<p>Su funcionamiento se baja en un exhaustivo examen de los detalles procedimentales del codigo</p>
				<p>Hay que obtener casos de prueba que aseguren:</p>
					<ul>
						<li>Se ejecuta por lo menos una vez todos los caminos de cada modulo</li>
						<li>Todas las sentencias sean ejecutadas al menos una vez</li>
						<li>Todas las decisiones logicas se ejecuten al menos una vez en parte verdadera y otra falsa</li>
						<li>Todos los bucles sean ejecutados en sus limites</li>
						<li>Se usen todas las estructuras de datos internas que aseguren su validez</li>

					</ul>

			<h3> Pruebas de caja NEGRA</h3>
				<p>O pruebas de comportamiento</p>
				<p>Se realizan sobre la interfaz, sin necesidad de conocer el codigo</p>
				<p>Se busca demostrar que las funciones del software son operativas</p>
				<p>Se busca encontrar errores en: <br>
				-Errores de interfaz, en estructuras de datos o en las bases de datos externas.<br>
				-Funcionalidades erroneas en el inicio o la finalizacion del programa</p>
				<p>Algunas tecnicas para estos casos son:<br>
					-Clases de equivalencia<br>
					-Analisis de valores limite
				</p>
		 </article>


		<article> <h2> Estrategias de pruebas de software. Automatizadion de pruebas</h2>
			<img src="Fotos/Espiral pruebas.JPG">
			
			<ul>
				<li><b>Prueba de unidad</b> esta centrada en la unidad mas pequena, el modulo, tal cual esta en el codigo</li>
				<li><b>Prueba de integracion</b>Se construlle la estructura con los modulos probados anteriormente. El diseno sera el foco de atencion.</li>
				<li><b>Prueba de validacion</b> es la prueba en el entorno final de trabajo</li>
				<li><b>Prueba de sistema</b> Se prueba que cada elemento este construido de forma eficaz. El software se prueba como un todo</li>

			</ul>

			<h3> Pruebas de unidad</h3>
				<p>Se utilizan pruebas de caja negra y caja blanca</p>
				<p>Se realizaran pruebas sobre:
					<ul>
						<li>La interfaz del modulo</li>
						<li>La estructura de datos locales</li>
						<li>Las condiciones limite</li>
						<li>Caminos independientes de la estructura de control</li>
						<li>Todos los caminos de manejo de errores</li>
					</ul>
				</p>
				<h4>Se utiliza el JUnit</h4>

			<h3>Pruebas de integracion </h3>
				<p>Se prueban los modulos de forma conjunta</p>
				<p>Se puede enfocar de dos formas distintas:
					
						<h4>Integracion no incremental o big bang</h4> 
							<p>Se prueba cada modulo por separado y despues todos juntos Se detectan muchos errores y la correccion es dificil.</p>

						<h4>Integracion incremental</h4>
							<p>Se prueba el programa poco a poco. Se puede optar por dos estrategias:
								<ul>
									<li><b>Ascendente</b> Se comienza con los modulos mas bajos del programa</li>
									<li><b>Descendente</b> Se empieza por el modulo principal.</li>
								</ul>
							</p>		
				</p>


			<h3>Pruebas de validacion</h3>
				<p>Daran comienzo cuando:
					<ul>
						<li>El software ya esta ensamblado y los errores corregidos</li>
						<li>Las pruebas estan realizadas de tal forma que las acciones ya son visibles para el usuario</li>
						<li>Se cumple el documento expecificado de requisitos del software</li>
					</ul>

				</p>
				<p>Se lleva a cabo con las tecnicas de caja negra. Se podran usar estas tecnicas:
					<ul>
						<li><b>Prueba alfa</b> realizada por el cliente en el lugar de desarrollo.</li>
						<li><b>Prueba beta</b> se realiza en el lugar de trabajo.El usuario sera el que registre los errores y los comunique.</li>

					</ul>

				</p>


			<h3>Pruebas del sistema</h3>
				<p>Esta conformada por varias pruebas que tendran como mision ejercitar en profundidad el software. Seran las siguientes:
					<ul>
						<li><b>Prueba de recuperacion</b> se fuerza el fallo para ver como se recupera</li>
						<li><b>Prueba de seguridad</b></li>
						<li><b>Prueba de resistencia(stress)</b> se lleva el sistema al limite de los recursos, sometiendolo a cargas masivas. El objetivo es comprobar los extremos del sistema.</li>
					</ul>
				</p>
		 </article> 


		<article> <h2> JUnit</h2>
			<p>Esta integrada en Eclipse</p>
			<p>Las pruebas de realizan sobre una clase independiente del resto de clases</p>


			<h3> Librerias</h3>
				<p>En caso de que no esten en el IDE</p>
				<a href ="https://junit.org/junit5/"> Librerias JUnit  </a>


			<h3>Metodos</h3>
				<table class="comandos">
					<tr>
						<td><b>assertTrue</b>(<i>boolean expression</i>)<br> <b>assertTrue</b>(<i>String mensaje, boolean expression</i>) </td>
						<td>Comprueba que la expresion se evalue <b>TRUE</b>, si no lo es y se incluye String lanza el mensaje</td>
					</tr>
					<tr>
						<td><b>assertFalse</b>(<i>boolean expression</i>)<br><b> assertFalse</b>(<i>String mensaje, boolean expression</i>)</td>
						<td>Comprueba que se evalue como <b>False</b> y si no lanza el mensaje del string</td>
					</tr>
					<tr>
						<td><b>assertEquals</b>(<i>valorEsperado, valorReal</i>)<br><b>assertEquals</b>(<i>String mensaje, valorEsperado, valorReal</i>)</td>
						<td>Comprueba que el valorEsperado sea igual al valorReal.valorEsperado y valorReal pueden ser diferente tipo</td>
					</tr>
					<tr>
						<td><b>assertNull</b>(<i>Object objeto</i>)<br><b>assertNull</b>(<i>String mensaje, Object objeto</i>)</td>
						<td>Comprueba que el objeto sea Null.</td>
					</tr>
					<tr>
						<td><b>assertNotNull</b>(<i>Object objeto</i>)<br><b>assertNotNull</b>(<i>String mensaje, Object objeto </i>)</td>
						<td>Comprueba que no sea Null</td>
					</tr>
					<tr>
						<td><b>assertSame</b>(<i>Object objetoEsperado, Object objetoReal</i>)<br><b>assertSame</b>(<i>String mensaje, Object objetoEsperado, Object objetoReal</i>)</td>
						<td>Comprueba que el objeto real y el esperado sean el mismo</td>
					</tr>
					<tr>
						<td><b>assertNotSame</b>(<i>Object objetoEsperado, Object objetoReal</i>)<br><b>assertNotSame</b>(<i>String mensaje, Object objetoEsperado, Object objetoReal</i>)</td>
						<td>Comprueba el objeto esperado y el objeto real no sean el mismo objeto.</td>
					</tr>
					<tr>
						<td><b>fail</b>() <b>fail</b>(<i>String mensaje</i>)</b></b></td>
						<td>Hace que la prueba falle y si se pone el String lo saca por mensaje</td>
					</tr>
				</table>


			<h3>Tipos de anotaciones</h3>
				<p>Estas anotaciones permiten ejecutar el codigo antes y despues de las pruebas</p>
				<ul>
					<li><b>@BBefore</b>Si queremos que se inicie un metodo antes de que se ejecute cualquier metodo de prueba</li>
					<li><b>@BAfter</b> se esjecuta despues de cualquier tipo de prueba</li>
					<li><b>@BBeforeClass</b>Se inicia al principio de realizar las pruebas.Con esta etiqueta solo puede haber un metodo</li>
					<li><b>@BAfterClass</b>Se ejecutara una vez terminen las pruebas. Solo puede haber un metodo con esta etiqueta</li>
				</ul>


			<h3>Pruebas parametrizadas</h3>
				<p>Ejecutar una prueba varias veces con distintos valores.Seguir los siguientes pasos
					<ul>
						<li>Anadir la etiqueta <b>@RunWith(Parameterized.class)</b>A la clase de prueba. Con esto se indica que se usara para realizar varios tipos de prueba. Se declara un parametro por cada tipo de prueba y un constructor tendra tantos argunmentos como parametros</li>

						<li> Para volver a la lista de valores que testear, se incluye en el metodo la etiqueta <b>@Parameters</b>.</li>
					</ul>
				</p>		
		 </article>



		<article><h2> Pruebas de codigo: cobertura, valores limite, clases de equivalencia</h2>

			<h3> Pruebas del camino basico</h3>
				<p>Es una tecnica que mediante pruebas de caja blanca permite al desarrollador obtener una medida de la complejidad del sistema.Para obtener la medida se utiliza la tecnica de represnetacion de <b>grafos de flujo</b>.</p>
				<img src="Fotos/Grafos de flujo.jpg">

				<p>Cada circulo es un <b>nodo</b> representa una o mas sentencias procedimentales</p>
				<p>Las flechas se llaman <b>aristas</b> o <b>enlaces</b>. Terminaran en un nodo aunque este no tenga sentencia procedimental.</p>
				<p>Las regiones son  areas delimitadas por aristas y nodos. El area exterior es otra region.</p>
				<p>El nodo predicado contendra una condicion y de el salen dos aristas dependiendo de esa condicion.</p>

				<h4> Complejidad ciclomatica  V(G) </h4>
					<p>Metrica del software que proporciona una medida de la complejidad logica de un programa.</p>
					<p>Establece el numero de casos de prueba que debera ejecutarse  para que todo sea probado una vez</p>

				<h4> V(G) Se puede calcular de tres formas</h4>
					<ul>
						<li>V(G) = numero de regiones del grafo.</li>
						<li>V(G) = aristas - nodos + 2</li>
						<li>V(G) = nodos predicado + 1</li>
					</ul>
				
				<h4> Valores de referencia</h4>
					<table>
						<tr>
							<td>Entre 1 y 10</td>
							<td>Sencillo sin mucho riesgo</td>
						</tr>

						<tr>
							<td>Entre 11 y 20</td>
							<td>mas complejo, riesgo moderado</td>
						</tr>
						<tr>
							<td>Entre 21 y 50</td>
							<td>complejo, alto riesgo</td>
						</tr>
						<tr>
							<td> >50</td>
							<td>no testeable, muy alto riesgo</td>
						</tr>
					</table>

				<h4>Obtencion de casos de prueba</h4>
					<p>Buscar los casos de prueba necesarios para recorrer todos los caminos</p>


			<h3>Particion o clases de equivalencia</h3>		
				<p>Se trata de dividir los valores de los campos de entrada en:<br>
					-<b>Clases balidas</b> valores de entrada dentro de los limites<br>
					-<b>Clases no validas</b> valores de entrada por fuera de les extremos.</p>


			<h3> Analisis de valores limite. Casos de prueba</h3>
				<p>Se trata de hacer un analisis en todos los valores limites  y por fuera de los limites.</p>


			<h3>Pruebas funcionales, pruebas estructurales y pruebas de refgresion</h3>
				<p>Las pruebas funcionales se definen a partir de las caracteristicas descritas en la documentacion.Son pruebas de caja negra</p>
				<p>Las pruebas estructurales nos indican si las diferentes estrategias de prueba se han llevado a cabo correctamente. Si todas las pruebas encajan la arquitectura el software es correcta</p>
				<p>Las pruebas de regresion cosisten en volver parte del sistema despues de haberlo modificado.Estas pruebas se realizan sobre componentes ya probados.</p>
			

			<h3>Medidas de calidad</h3>
				<p>Principio anios  80, Maurice Halstead, desarrolla un conjunto de normas y metricas que sustentan el calculo de palabvras clave y variables del codigo</p>
				<p>Esta basada en contar los operadores y operandos que hau en un programa: </p>
				<ul>
					<li><b>n1</b> numero de operadores unicos</li>
					<li><b>n2</b>numero de operandos unicos</li>
					<li><b>N1</b>numero total de ocurrencias de operadores</li>
					<li><b>N2</b>numeros total de ocurrencias de operandos</li>
				</ul>

				<h4>Calculos</h4>
				<ul>
					<li><b>Longitud:</b>  N = N1 + N2   <i>medida del tamanio del programa</i></li>
					<li><b>Volumen:</b>  N * log2(n),  <i>donde n= n1 + n2</i></li>
					<li><b>Dificultad:</b>  D =((n1*n2) / (n2*2))   <i>directamente proporcional al numero de operadores unicos</i></li>
					<li><b>Esfuerzo:</b> E = V * D <i>Esfuerzo por entender un programa o mantenerlo, proporcional al volumen y a su dificultad</i> </li>
					<li><b>Nivel:</b> L = 1 / D <i>Inversamente proporcional a su dificultad</i></li>
				</ul>


			<h3>Herramientas de depuracion de codigo</h3>
				<h4>linter</h4>
				 <a href="https://plugins.jetbrains.com/plugin/12496-go-linter"> El enlace es para el JetBrains.</a>
		 </article>



		<article> <h2>Tecnica refactorizacion</h2>

			<h3>Cuando refactorizar(bad smell)</h3>
				<ul>
					<li>Codigo duplicado(duplicated code)</li>
					<li>metodos muy largos(long method)</li>
					<li>clases muy grandes(large class)</li>
					<li>listas de paramet rso extensa(long parameter list)</li>
					<li>cambio divergente(divergente change)</li>
					<li>cirugia a tiro pistola(shotgun surgery)</li>
					<li>envidia de funcionalidad(feature envy)</li>
					<li>clase de solo datos(data class)</li>
					<li>legado rechazado(refused bequest)</li>
				</ul>


			<h3>Aspectos importantes</h3>
				<p>Se reestructura el codigo sin que cambie el como funciona</p>
				<p>El IDE conoce las realciones entre metodos y clases, deberia de encargarse de propagar los cambios</p>
				<p>Antes de refactoriuzar definir bien los casos de prueba:
					<ul>
						<li>Automaticos</li>
						<li>reportar los casos de fallos y errores</li>
						<li>deben de poder ejecutarse de forma independiente</li>
					</ul>
				</p>
				<p>Muy importante documentarlo todo</p>
			
			<h3>Prueba unitarias</h3>
				<p>Importrancia de las pruenbas al refactorizar</p>
					<ul>
						<li>Nos previenen las pruebas de regresion</li>
						<li>Facilitan refactoriar</li>
						<li>Mejoran como esta disenada la implementacion</li>
					</ul>
				<p>Lo dificil no es picar el codigo, sino tener muy claro que es lo que tiene que hacer</p>

			<h3>Ventajas de refactorizar</h3>
				<ul>
					<li>facilita la comprension del cogido</li>
					<li>favorece detectar errores</li>
					<li>mayor rapideza en la programacion</li>
					<li>mayor calidad durante el proceso</li>
				</ul>

			<h3>Desventajas</h3>
				<ul>
					<li>Migraciones implican cambios estructurales de datos</li>
					<li>El cambio de interfaz sin acceso al cogido fuente puede ser problematico</li>
				</ul>
		 </article>


		<article><h2>Patrones de dieño</h2>

			<h3>Estructura</h3>
				<ul>
					<li>Nombre</li>
					<li>Problema</li>
					<li>Solucion</li>
					<li>Consecuencias</li>
				</ul>


			<h3>Tipos</h3>
				<ul>
					<li>Estructurales</li>
					<li>Comportamiento</li>
					<li>Creacionales</li>
				 </ul>
				

			<h3> Mas importantes</h3>
				<a href="https://refactoring.guru/es"> Web guapa</a>
			
		 </article>


		<article> <h2>Control de versiones</h2>

			<h3>Estructura</h3>
				<ul>
					<li>repositorio</li>
					<li>revision o version</li>
					<li>etiqueta o rotular(tag)</li>
					<li>tronco(trunk)</li>
					<li>rama(Branch)</li>
					<li>desplegar(checkout)</li>
					<li>confirmar(commit o check-in)</li>
					<li>exportacion(export)</li>
					<li>importacion</li>
					<li>actualizar(update)</li>
					<li>fusion(update)</li>
					<li>conflicto</li>
					<li>resolver conflicto</li>
				</ul>

			<h3>herramientas</h3>
				<ul>
					<li>Git (Github)</li>
					<li>subversion (en eclipse)</li>
			 	</ul>

		 </article>


		<article><h2>Documentacion</h2>
		 	<img src="Fotos/IDES docu.JPG">

		 	<h3>Javadoc(en Eclipse)</h3>
		 		<h4> Etiquetas</h4>
		 			<ul>
		 				<li><b>@author</b>autor de la clase</li>
		 				<li><b>@version</b>version de la clase</li>
		 				<li><b>@see</b>referencia otra clase</li>
		 				<li><b>@param</b>descripcion del parametro</li>
		 				<li><b>@return</b>decripcion de lo que devuelve</li>
		 				<li><b>@throws</b>decripcion de la excepcion que puede propagar</li>
		 				<li><b>@since</b>numero version producto</li>
		 			</ul>

		 </article>

	</section>

<!--  ========================================    UF3 UML   ================= -->
	<section><h1>UF3 UML (diseño orientado a objetos)</h1>

		<article><h2>Diagramas</h2>
			<img src="Fotos/diagramas arbol.JPG">

			<h3>Campos de aplicacion</h3>
				<ul>
					<li>Diagrama de casos de uso</li>
					<li>Diagrama de actividad</li>
					<li>Diagrama de estado</li>
					<li>Diagrama de secuencia</li>
					<li>Diagrama de comunicacion</li>
					<li>Diagrama de tiempos</li>
					<li>Diagrama de vista global de inteccion</li>
				</ul>

			<h3>Diagramas de comportamiento</h3>
				<p>permiten modelar la informacion de los diagramas de clases.</p>
				<h4>Se clasifican en:</h4>
				<ul>
					<li><b>Diagrama de casos de uso</b> describe el comportamiento del sistema desde el punto de vista del usuario</li>
					<li><b>diagrama de actividad</b> parecido al daigrama de flujo, muestra pasos, puntos de decision y bifurcaciones</li>
					<li><b>diagrama de estado</b> estados de un objeto y transiciones de uno a otro</li>
					<li><b>Diagrama de secuencia</b> interaccion de unos objetos con otros</li>
					<li><b>diagrama de comunicacion</b> iteraciones entre elementos en tiempo de ejecucion</li>
					<li><b>diagrama de tiempos</b>define comportamiento de objetos a una escala de tiempo</li>
					<li><b>diagrama de vista global de interaccion</b>cooperacion entre otros diagramas de interaccion</li>

				</ul>

		 </article>


		<article><h2>Diagrama de clases</h2>

			<p>Una representacion grafica y estatica de las estructura general de un sistema, mostrando cada una de las clases y sus relaciones representadas en bloques</p>

			<h3>Objetos</h3>
				<p>Es la instancia de una clase</p>
				<p>Esta constituido por un conjunto de atributos, metodos e identidad propia</p>
				<p> propiedades clave:
				<ul>
					<li><b>abstraccion</b> las caracteristicas y comportamientos del objeto</li>
					<li><b>escapsulacion</b> ocultar los metodos etc del exterior y mostrar solo lo necesario</li>
					<li><b>modularidad</b></li>
					<li><b>polimorfismo</b>dos instancias presistentes de dsiteintas clases puede responder a la misma llamada a metodos del mismo nombre, cada uno con distinto comportamiento encapsulado. interfaz comun, herencia</li>
					<li><b>tipificacion</b>definicion precisa de ub objeto</li>
					<li><b>concurrencia</b>propiedad de un objeto que estra activo respecto de otro que no lo esta</li>
					<li><b>presistencia</b>propeidad de un objetom, su existencia cuando el programa se cierra</li>
				</ul></p>


			<h3>Clases</h3>
				<p>Son la unidad basica que contiene toda la informacion referente a un objeto.</p>
				<img src="Fotos/end dess clase.JPG">


			<h3>Atributos y metodos</h3>
				<ul>
					<li><b>+</b>Public</li>
					<li><b>-</b>Private , solo la propia clase</li>
					<li><b>#</b>Protected, tambien herencia</li>
					<li><b>~</b>Package</li>
				</ul>


			<h3>Relaciones</h3>
				<ul>
					<img src="Fotos/end dess clase relaciones.JPG">
					<li><b>0..1</b> cero o una vez</li>
					<li><b>1</b></li>
					<li><b>0..*</b></li>
					<li><b>1..*</b></li>
					<li><b>M..N</b></li>
				</ul>


			<h3>tipos de asociacion</h3>
				<ul>
					<li>Direccionales</li>
					<li>Bidireccionales</li>
					<li>Reflexivas</li>
				</ul>


			<h3>Clase asociacion</h3>
				<p>Cuando una clase contiene informacion para la union entre dos clases</p>
					<img src="Fotos/end dess clase asociacion.JPG">


			<h3>Herencia</h3>
				<img src="Fotos/end dess clase herencia.JPG">


			<h3>Composicion</h3>
				<p><b>Fuerte</b> <i>Rombo relleno</i>. los objetos estan constituidos por componentes. La supresion del objeto comporta la supresion de los componentes. Uno a varios<br>
					<img src="Fotos/end dess clasecomposicion fuerte.JPG">
				</p>

				<p><b>Debil</b> <i>Rombo vacio</i>.  la destruccion del objeto no implica destruir los componentes que pueden estar compartidos con otros objetos<br>
					<img src="Fotos/end dess clasecomposicion devil.JPG">
				</p>


			<h3>Dependencia</h3>
				<p>una clase utiliza la otra<br>
					<img src="Fotos/end dess clase dependencia.JPG">
				</p>


			<h3>Herramientas</h3>

				<h4>Papyrus para Eclipse</h4>
					<p>Es un plugin de codigo abierto</p>
					<p>Caracteristicas:
						<ul>
							<li>Codigo acierto basado en el Eclipse</li>
							<li>Proporciona entorno integrado para editar cualquier EFM(metamodelos)</li>
							<li>Proporciona editores de diagramas para UML2 y SysML</li>
							<li>Soporte de perfil de usuario</li>
							<li>Formar de personalizacion potentes</li>
						</ul>
					</p>

					<p>Solo hay que descargar el plugin y ejecutar el EXE</p>


		 </article>


		<article><h2>Diagrama de casos de uso</h2>

			<p>Es importate tenerlo controlado</p>
			<p>Modelan el sistema desde el puto de vista del usuario</p>
			<p>Lebguaje sencillo, debera describir todas las formas de utilizar el sistema. Define todo el comportamiento del programa</p>

			<h3>Objetivos</h3>
				<ul>
					<li>Definir requisitos funcionales y operatrivos</li>
					<li>Descripcion iteraccion usuario/sistema</li>
					<li>Base para validacion de pruebas</li>
				</ul>

			<h3>Elementos</h3>

				<ul>
					<li><b>actores </b>cualquier agente que interactua con el sistema</li>
					<li><b>casos de uso </b> una unidad funcional del sistema. Sera inicado por un actor yt otros actores podran partricipar de el.</li>
					<li><b>relaciones</b></li>
					<li><b>sistema</b> delimitado por un rectangulo</li>
				</ul>


				<h4>Actores</h4>
					<p>para poder intreradctuar con el sistema, hay que conocer la informacion dew dcada elemento y saber que y quien interactua con el sistema y que rol trandra.Puntos a la hora de definir actores:</p>
					<ul>
						<li>Externos al sistema</li>
						<li>interactuan directamente</li>
						<li>Representan roles de personas</li>
						<li>Nombre con funcion que desenpenan</li>
						<li>Una persona puede desempenar varios roles</li>
					</ul>


			<h4>Identificar casos de uso</h4>
				<p>Sera necesario entender el funcionamiento de lsistema. Se documentan a traves de una plantilla.</p>
				<img src="Fotos/casos dew uso tabla.JPG">



			<h4>Relaciones</h4>
				<img src="Fotos/casos de uso relaciones2 .jpg">
				<img src="Fotos/casos dew uso relaciones.JPG">
				<p><b>Include</b> obliga a usar los metodos</p>
				<p><b>Extend</b> amplia los casos de uso, no es necesario hacer lo que se extiende</p>




			<h3>Ejemplo</h3>
				<img src="Fotos/caso de uso.jpg">

		 </article>


	 </section>


</body><!-- \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\ -->

</html>